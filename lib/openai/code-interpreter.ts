/**
 * OpenAI Code Interpreter Service
 * 
 * Handles chart generation using OpenAI's Code Interpreter tool via the Responses API.
 * Creates containers, uploads CSV files, and generates data visualizations.
 */

import OpenAI from 'openai'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

export interface CodeInterpreterConfig {
  dataFile?: {
    buffer: Buffer
    filename: string
  }
  prompt: string
  chartConfig?: {
    aspectRatio?: string
    format?: 'png' | 'jpg' | 'svg'
    dpi?: number
  }
}

export interface CodeInterpreterResult {
  success: boolean
  imageBuffer?: Buffer
  containerId?: string
  error?: string
  metadata?: {
    containerId: string
    filesGenerated: string[]
    executionTime: number
  }
}

export interface ChartCodeResult {
  success: boolean
  pythonCode?: string
  containerId?: string
  error?: string
  metadata?: {
    containerId: string
    executionTime: number
  }
}

/**
 * Generates Python chart code using OpenAI Code Interpreter (no file saving)
 */
export async function generateChartCode(
  config: CodeInterpreterConfig
): Promise<ChartCodeResult> {
  const startTime = Date.now()
  let containerId: string | undefined

  try {
    console.log('üöÄ Starting Code Interpreter chart code generation...')
    
    // Step 1: Create container
    console.log('üì¶ Creating OpenAI container...')
    const container = await openai.containers.create({
      name: `chart-code-generation-${Date.now()}`,
    })
    containerId = container.id
    console.log(`‚úÖ Container created: ${containerId}`)

    // Step 2: Upload data file if provided
    if (config.dataFile) {
      console.log('üìÅ Uploading data file to container...')
      
      // Determine MIME type based on file extension
      const fileExt = config.dataFile.filename.split('.').pop()?.toLowerCase()
      const mimeTypes: Record<string, string> = {
        'csv': 'text/csv',
        'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'xls': 'application/vnd.ms-excel',
        'json': 'application/json',
        'txt': 'text/plain',
        'pdf': 'application/pdf',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'doc': 'application/msword',
        'xml': 'application/xml',
        'html': 'text/html',
        'md': 'text/markdown'
      }
      const mimeType = mimeTypes[fileExt || ''] || 'application/octet-stream'
      
      const dataFile = await openai.containers.files.create(containerId, {
        file: new File([config.dataFile.buffer], config.dataFile.filename, {
          type: mimeType
        })
      })
      console.log(`‚úÖ Data file uploaded: ${dataFile.id} (${fileExt?.toUpperCase()})`)
    }

    // Step 3: Generate chart code using Code Interpreter
    console.log('üìä Generating chart code with Code Interpreter...')
    const response = await openai.responses.create({
      model: "gpt-4o",
      tools: [{
        type: "code_interpreter",
        container: {
          type: "auto",
          file_ids: config.dataFile ? [] : undefined // Will use the uploaded file
        }
      }],
      tool_choice: "required",  // Force Code Interpreter to run
      input: config.prompt,
      max_output_tokens: 4000,
    })

    console.log('‚úÖ Code Interpreter response received')

    // Step 4: Extract Python code from response
    let pythonCode: string | undefined

    // Look for code in the response
    if (response.output && response.output.length > 0) {
      for (const output of response.output) {
        if (output.type === 'code_interpreter_call' && output.code) {
          console.log('üìù Found Python code in Code Interpreter call')
          pythonCode = output.code
          break
        }
        
        if (output.type === 'message' && output.content) {
          for (const content of output.content) {
            if (content.type === 'text' && content.text) {
              // Look for code blocks in the text
              const codeBlockMatch = content.text.match(/```python\n([\s\S]*?)\n```/)
              if (codeBlockMatch) {
                console.log('üìù Found Python code block in text response')
                pythonCode = codeBlockMatch[1]
                break
              }
            }
          }
        }
      }
    }

    if (!pythonCode) {
      throw new Error('No Python code was generated by Code Interpreter')
    }

    const executionTime = Date.now() - startTime
    console.log(`‚úÖ Chart code generation completed in ${executionTime}ms`)
    console.log(`üìù Generated code length: ${pythonCode.length} characters`)

    return {
      success: true,
      pythonCode,
      containerId,
      metadata: {
        containerId,
        executionTime
      }
    }

  } catch (error) {
    console.error('‚ùå Code Interpreter chart code generation failed:', error)
    
    // Clean up container on error
    if (containerId) {
      try {
        await openai.containers.delete(containerId)
        console.log(`üßπ Cleaned up container: ${containerId}`)
      } catch (cleanupError) {
        console.error('‚ùå Failed to cleanup container:', cleanupError)
      }
    }

    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
      containerId
    }
  }
}

/**
 * Creates a chart using OpenAI Code Interpreter
 */
export async function createChartWithCodeInterpreter(
  config: CodeInterpreterConfig
): Promise<CodeInterpreterResult> {
  const startTime = Date.now()
  let containerId: string | undefined

  try {
    console.log('üöÄ Starting Code Interpreter chart generation...')
    
    // Step 1: Create container
    console.log('üì¶ Creating OpenAI container...')
    const container = await openai.containers.create({
      name: `chart-generation-${Date.now()}`,
    })
    containerId = container.id
    console.log(`‚úÖ Container created: ${containerId}`)

    // Step 2: Upload data file if provided
    if (config.dataFile) {
      console.log('üìÅ Uploading data file to container...')
      
      // Determine MIME type based on file extension
      const fileExt = config.dataFile.filename.split('.').pop()?.toLowerCase()
      const mimeTypes: Record<string, string> = {
        'csv': 'text/csv',
        'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'xls': 'application/vnd.ms-excel',
        'json': 'application/json',
        'txt': 'text/plain',
        'pdf': 'application/pdf',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'doc': 'application/msword',
        'xml': 'application/xml',
        'html': 'text/html',
        'md': 'text/markdown'
      }
      const mimeType = mimeTypes[fileExt || ''] || 'application/octet-stream'
      
      const dataFile = await openai.containers.files.create(containerId, {
        file: new File([config.dataFile.buffer], config.dataFile.filename, {
          type: mimeType
        })
      })
      console.log(`‚úÖ Data file uploaded: ${dataFile.id} (${fileExt?.toUpperCase()})`)
    }

    // Step 3: Generate chart using Code Interpreter
    console.log('üìä Generating chart with Code Interpreter...')
    const response = await openai.responses.create({
      model: "gpt-4o",
      tools: [{
        type: "code_interpreter",
        container: {
          type: "auto",
          file_ids: config.dataFile ? [] : undefined // Will use the uploaded file
        }
      }],
      tool_choice: "required",  // Force Code Interpreter to run
      input: config.prompt,
      max_output_tokens: 4000,
    })

    console.log('‚úÖ Code Interpreter response received')

    // DEBUG: Log the entire response structure
    console.log('üìã Response output length:', response.output?.length || 0)
    if (response.output && response.output.length > 0) {
      response.output.forEach((output, index) => {
        console.log(`  Output ${index}: type=${output.type}`)
        if (output.type === 'message' && output.content) {
          console.log(`    Content items: ${output.content.length}`)
          output.content.forEach((content, cIndex) => {
            console.log(`      Content ${cIndex}: type=${content.type}`)
            if (content.type === 'text') {
              console.log(`        Full Text Output:`)
              console.log(`        ==================`)
              console.log(content.text || '(no text)')
              console.log(`        ==================`)
              console.log(`        Annotations: ${content.annotations?.length || 0}`)
              if (content.annotations && content.annotations.length > 0) {
                console.log(`        Annotation details:`, JSON.stringify(content.annotations, null, 2))
              }
            }
          })
        }
        if (output.type === 'code_interpreter_call') {
          console.log(`    Full Code Executed:`)
          console.log(`    ==================`)
          console.log(output.code || '(no code)')
          console.log(`    ==================`)
          console.log(`    Status: ${output.status}`)
        }
      })
    }

    // Step 4: Extract generated files from response
    const generatedFiles: string[] = []
    let imageBuffer: Buffer | undefined

    // Look for file citations in the response
    if (response.output && response.output.length > 0) {
      for (const output of response.output) {
        if (output.type === 'message' && output.content) {
          for (const content of output.content) {
            if (content.type === 'text' && content.annotations) {
              for (const annotation of content.annotations) {
                if (annotation.type === 'container_file_citation') {
                  const fileId = annotation.file_id
                  const filename = annotation.filename
                  
                  if (filename && (filename.endsWith('.png') || filename.endsWith('.jpg') || filename.endsWith('.svg'))) {
                    console.log(`üì∏ Found generated chart file: ${filename}`)
                    generatedFiles.push(filename)
                    
                    // Download the file content
                    try {
                      const fileContent = await openai.containers.files.retrieveContent(containerId, fileId)
                      imageBuffer = Buffer.from(await fileContent.arrayBuffer())
                      console.log(`‚úÖ Downloaded chart image: ${filename} (${imageBuffer.length} bytes)`)
                    } catch (downloadError) {
                      console.error(`‚ùå Failed to download file ${filename}:`, downloadError)
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // If no files found in annotations, try to get files from container
    if (!imageBuffer && containerId) {
      console.log('üîç No files found in response annotations, checking container files...')
      try {
        const containerFiles = await openai.containers.files.list(containerId)
        
        console.log(`üìÇ Container has ${containerFiles.data.length} total files:`)
        containerFiles.data.forEach((file, index) => {
          console.log(`  File ${index}: id=${file.id}, path=${file.path}, source=${file.source}`)
        })
        
        for (const file of containerFiles.data) {
          const filename = file.path?.split('/').pop() || ''
          console.log(`üîé Checking file: ${file.path} (filename: ${filename})`)
          
          if (filename === 'chart.png' || file.path?.includes('chart.png') || 
              file.path?.endsWith('.png') || file.path?.endsWith('.jpg') || file.path?.endsWith('.svg')) {
            console.log(`üì∏ Found chart file in container: ${file.path}`)
            generatedFiles.push(file.path)
            
            try {
              const fileContent = await openai.containers.files.retrieveContent(containerId, file.id)
              imageBuffer = Buffer.from(await fileContent.arrayBuffer())
              console.log(`‚úÖ Downloaded chart image: ${file.path} (${imageBuffer.length} bytes)`)
              break // Use the first image found
            } catch (downloadError) {
              console.error(`‚ùå Failed to download file ${file.path}:`, downloadError)
            }
          }
        }
      } catch (listError) {
        console.error('‚ùå Failed to list container files:', listError)
      }
    }

    if (!imageBuffer) {
      throw new Error('No chart image was generated by Code Interpreter')
    }

    const executionTime = Date.now() - startTime
    console.log(`‚úÖ Chart generation completed in ${executionTime}ms`)

    return {
      success: true,
      imageBuffer,
      containerId,
      metadata: {
        containerId,
        filesGenerated: generatedFiles,
        executionTime
      }
    }

  } catch (error) {
    console.error('‚ùå Code Interpreter chart generation failed:', error)
    
    // Clean up container on error
    if (containerId) {
      try {
        await openai.containers.delete(containerId)
        console.log(`üßπ Cleaned up container: ${containerId}`)
      } catch (cleanupError) {
        console.error('‚ùå Failed to cleanup container:', cleanupError)
      }
    }

    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
      containerId
    }
  }
}

/**
 * Helper function to create a more specific chart generation prompt
 */
export function buildChartGenerationPrompt(
  dataDescription: string,
  chartType: string,
  options: {
    dataFilename?: string
    aggregationType?: string
    units?: string
    dataLabels?: boolean
    legends?: string
    gridlines?: string
    callouts?: boolean
    calloutThreshold?: number
    aspectRatio?: string
  } = {}
): string {
  const {
    dataFilename,
    aggregationType = 'auto',
    units,
    dataLabels = false,
    legends = 'auto',
    gridlines = 'light',
    callouts = false,
    calloutThreshold = 3,
    aspectRatio = '16:9'
  } = options

  const promptParts: string[] = []

  // Data source with format detection
  if (dataFilename) {
    const fileExt = dataFilename.split('.').pop()?.toLowerCase()
    let dataInstruction = ''
    
    switch (fileExt) {
      case 'csv':
        dataInstruction = `Read the data from the uploaded CSV file: ${dataFilename}`
        break
      case 'xlsx':
      case 'xls':
        dataInstruction = `Read the data from the uploaded Excel file: ${dataFilename}. Use pandas to read Excel data.`
        break
      case 'json':
        dataInstruction = `Read the data from the uploaded JSON file: ${dataFilename}. Parse the JSON structure appropriately.`
        break
      case 'pdf':
        dataInstruction = `Extract tabular data from the uploaded PDF file: ${dataFilename}. Use appropriate libraries to extract tables.`
        break
      case 'txt':
        dataInstruction = `Read the data from the uploaded text file: ${dataFilename}. Parse the data structure intelligently.`
        break
      case 'xml':
        dataInstruction = `Read the data from the uploaded XML file: ${dataFilename}. Parse XML structure to extract data.`
        break
      default:
        dataInstruction = `Read the data from the uploaded file: ${dataFilename}`
    }
    
    promptParts.push(dataInstruction)
  } else {
    promptParts.push(`Use this data: ${dataDescription}`)
  }

  // Chart configuration
  promptParts.push(`\nCreate a ${chartType} chart with the following specifications:`)
  promptParts.push(`- Chart type: ${chartType}`)
  promptParts.push(`- Aspect ratio: ${aspectRatio}`)
  
  if (aggregationType !== 'auto') {
    promptParts.push(`- Aggregation: ${aggregationType}`)
  }
  
  if (units) {
    promptParts.push(`- Units: ${units}`)
  }

  // Visual elements
  promptParts.push(`\nVisual elements:`)
  promptParts.push(`- Data labels: ${dataLabels ? 'Show' : 'Hide'}`)
  promptParts.push(`- Legend: ${legends}`)
  promptParts.push(`- Gridlines: ${gridlines}`)
  
  if (callouts) {
    promptParts.push(`- Callouts: Highlight top ${calloutThreshold} values`)
  }

  // Technical requirements
  promptParts.push(`\nTechnical requirements:`)
  promptParts.push(`- High DPI (300) for crisp output`)
  promptParts.push(`- Professional styling with clean design`)
  promptParts.push(`- Ensure all text is readable`)
  promptParts.push(`- Use appropriate color scheme for data distinction`)
  promptParts.push(`- Save as PNG with transparent background if applicable`)

  promptParts.push(`\nGenerate the chart and save it as 'chart.png'`)

  return promptParts.join('\n')
}

/**
 * Clean up container resources
 */
export async function cleanupContainer(containerId: string): Promise<void> {
  try {
    await openai.containers.del(containerId)
    console.log(`üßπ Cleaned up container: ${containerId}`)
  } catch (error) {
    console.error(`‚ùå Failed to cleanup container ${containerId}:`, error)
  }
}
