export interface ExecuteManimOptions {
  code: string;                 // The Python code generated by Code Interpreter
  sceneName: string;            // The class name inside scene.py
  uploadUrl?: string;           // Optional Supabase signed URL
  resolution?: string;          // 480p, 720p, 1080p
  aspectRatio?: string;         // 16:9, 9:16, 1:1
  duration?: number;            // Duration in seconds
  style?: string;               // auto, clean, cinematic, academic
}

/**
 * Execute validated Manim code in Modal and return result
 * Similar to executeChartCode but for Manim videos
 */
export async function executeManimOnModal({
  code,
  sceneName,
  uploadUrl,
  resolution = "720p",
  aspectRatio = "16:9",
  duration = 8,
  style = "auto",
}: ExecuteManimOptions) {
  try {
    console.log('üöÄ Executing Manim code in Modal...')
    console.log(`üìù Code length: ${code.length} characters`)
    console.log(`üé¨ Scene: ${sceneName}`)
    
    // Call Modal function via HTTP endpoint
    const requestBody = {
      code,
      scene_name: sceneName,
      upload_url: uploadUrl,
      resolution,
      aspect_ratio: aspectRatio,
      duration,
      style
    }
    
    const response = await fetch(process.env.MODAL_MANIM_ENDPOINT!, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    })
    
    if (!response.ok) {
      const errorText = await response.text()
      throw new Error(`Modal request failed: ${response.status} ${errorText}`)
    }
    
    const result = await response.json()
    
    if (!result.success) {
      throw new Error(`Modal Manim execution failed: ${result.error}`)
    }
    
    console.log(`‚úÖ Modal Manim execution completed successfully`)
    return {
      success: true,
      outputUrl: uploadUrl,
      logs: result.logs || '',
      stderr: result.stderr || '',
    }
    
  } catch (error) {
    console.error('‚ùå Modal Manim execution failed:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      logs: '',
      stderr: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

/**
 * Test Modal Manim connection
 */
export async function testModalManimConnection(): Promise<boolean> {
  try {
    console.log('üß™ Testing Modal Manim connection...')
    
    const testCode = `from manim import *

class TestScene(Scene):
    def construct(self):
        title = Text("Test Scene", font_size=48)
        self.play(Write(title))
        self.wait(1)
        self.play(FadeOut(title))`
    
    const result = await executeManimOnModal({
      code: testCode,
      sceneName: 'TestScene',
      resolution: '480p',
      aspectRatio: '16:9',
      duration: 3,
      style: 'clean'
    })
    
    if (result.success) {
      console.log('‚úÖ Modal Manim connection test successful')
      return true
    } else {
      console.log('‚ùå Modal Manim connection test failed:', result.error)
      return false
    }
  } catch (error) {
    console.error('‚ùå Modal Manim connection test error:', error)
    return false
  }
}

// Legacy function for backward compatibility (deprecated)
export async function runManimRender(options: ExecuteManimOptions) {
  console.warn('‚ö†Ô∏è runManimRender is deprecated, use executeManimOnModal instead')
  return executeManimOnModal(options)
}

// Helper function to get Manim quality flag based on resolution
export function getManimQualityFlag(resolution: string): string {
  const qualityMap: Record<string, string> = {
    '480p': '-ql',  // Low quality
    '720p': '-qh',  // High quality (default)
    '1080p': '-qk', // 4K quality
  };
  return qualityMap[resolution] || '-qh';
}

// Helper function to get Manim resolution string from aspect ratio and resolution
export function getManimResolution(aspectRatio: string, resolution: string): string {
  // Extract height from resolution (480p, 720p, 1080p)
  const height = parseInt(resolution.replace('p', ''));
  
  // Calculate width based on aspect ratio
  let width: number;
  switch (aspectRatio) {
    case '16:9':
      width = Math.round(height * 16 / 9);
      break;
    case '9:16':
      width = Math.round(height * 9 / 16);
      break;
    case '1:1':
      width = height;
      break;
    default:
      // Default to 16:9
      width = Math.round(height * 16 / 9);
  }
  
  return `${width}x${height}`;
}

// Helper function to get output path based on resolution
export function getManimOutputPath(sceneName: string, resolution: string): string {
  const qualityFlag = getManimQualityFlag(resolution);
  const qualityFolder = qualityFlag.replace('-q', '');
  
  // Map quality flags to folder names
  const folderMap: Record<string, string> = {
    'l': '480p15',
    'h': '720p30', 
    'k': '1080p60',
  };
  
  const folder = folderMap[qualityFolder] || '720p30';
  return `media/videos/scene/${folder}/${sceneName}.mp4`;
}

